## 最长公共前缀

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-common-prefix

### 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1：

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

### 题目分析

要找公共前缀，那肯定是对于每个字符串从前往后进行遍历，如果当前字符相等，则加入结果，继续向前；

如果遇到不相等的，就说明公共前缀已经找到。

我们可以将字符串数组排列如下：

```
[
 "flower",
 "flow",
 "flight"
]
```

将其看作一个行列矩阵，我们可以从第一列开始逐列比较，记当前列 curCol，如果每个字符串的当前列字符都相等，则继续向前，直到找到不相等的列，该列之前的字符串即为公共前缀。因为公共前缀肯定不可能比任一个字符串还长，所以取任一字符串的长度作为要遍历的列数即可，实际上列的遍历次数肯定不会超过最短的那个字符串。

### 实现代码

#### 逐列对比

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function (strs) {
  // 依次比较每个字符串的每一列，直到找到不相同的列，则该列之前即为最长公共前缀
  const row = strs.length
  const col = strs[0].length

  // 遍历列
  for (let i = 0; i < col; i++) {
    const c = strs[0][i]
    // 针对当前列，比较每个字符串的当前列字符是否和第一个字符串的该列字符相等
    for (let j = 1; j < row; ++j) {
      // 如果当前列不相同或者已经比较到最后一列了，那么最长公共前缀就已经找到了
      if (c !== strs[j][i] || i === strs[j].length) {
        return strs[0].substr(0, i)
      }
    }
  }
  return strs[0]
}
```

时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。

空间复杂度：O(1)，使用的额外空间复杂度为常数
